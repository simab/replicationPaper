## Note: Must be used on a Mac on order to run correctly
## Clear workspace
rm(list = ls())

## Load packages
library(tidyverse)
library(sf)
library(lubridate)
library(raster)
library(velox)
library(parallel)
library(foreign)
library(gsfuns)
library(nngeo)
library(haven)
library(here)

## Set working directory to own project folder
setwd(here("dataverse_files"))

################################################################################
################################################################################
################################################################################
## Prepare analysis dataset 1: EPR segment-level analysis
################################################################################
################################################################################
################################################################################

################################################################################
## Load data
################################################################################

## Load aggregated GeoEPR dataset
geoepr.ag <- st_read("geoepr_ag.geojson")

## Load EPR datasets: segment-level, ag-level
epr.seg.df <- read.csv("epr_segment_level_dataset.csv", 
                       stringsAsFactors = F)
epr.ag.df <- read.csv("epr_ag_level_dataset.csv",
                      stringsAsFactors =  F)

## Load Cshapes
cs <- st_read("cshapes_2.geojson")

## Load SDM/EPR Claims coding
epr.claims <- read.csv("epr_sdm_claims.csv", stringsAsFactors = F)
egip.claims <- read.csv("epr_sdm_egip_claims.csv", stringsAsFactors = F)

## Load Population raster
pop1880 <- raster("gtopo_lowres.tif")
pop1880.r <- reclassify(pop1880, cbind(NA, 0))

## Load Elevation raster
gtopo <- raster("popc_1880AD.asc")
gtopo.r <- reclassify(gtopo, cbind(NA, 0))

################################################################################
## Process data
################################################################################

## Convert startdate, enddate variables into date intervals
geoepr.ag$dateiv <- interval(geoepr.ag$sdate, geoepr.ag$edate)
cs$dateiv <- interval(cs$startdate, cs$enddate)

## Define number of cores for parallel operations
NCORES <- 8

#added
sf_use_s2(FALSE)

## Intersect group polygons with country borders (in parallel)
geoepr.cs <- do.call(rbind, mclapply(1:nrow(geoepr.ag), function(x){
  row <- geoepr.ag[x,]
  cs.polys <- cs %>% 
    filter(lengths(st_intersects(., row))>0,
           int_overlaps(dateiv, row$dateiv))
  return(st_intersection(row, cs.polys))
}, mc.cores = NCORES))


geoepr.cs <- sf::st_collection_extract(geoepr.cs, "POLYGON") 

## Remove points, line segments and sliver polygons generated by intersection
geoepr.cs <- geoepr.cs %>%  
  ungroup() %>%
  st_cast(., "POLYGON") %>%
  mutate(sub.area = as.numeric(st_area(geometry))*1e-6) %>%
  filter(sub.area > 50) %>%
  group_by(ag_id, groupname, gwcode, sdate, edate, dateiv, startdate, enddate, dateiv.1) %>%
  dplyr::summarize(geometry = st_union(geometry)) %>%
  ungroup() %>%
  mutate(seg.area = as.numeric(st_area(geometry))* 1e-6) %>% 
  st_cast("MULTIPOLYGON")

## Extract population estimates for each polygon (group segments within countries)
geoepr.cs$pop <- velox(pop1880.r)$extract(geoepr.cs, 
                                          fun = function(x){sum(x, na.rm = T)}, 
                                          small = T)

## Function to subtract current value from cumulative minimum
getTFIncr <- function(x){
  x.out <- x-cummin(x)
}

## Expand data on group segments within countries into yearly data
geoepr.cs.yrs <- geoepr.cs %>%
  mutate(syear = year(startdate), 
         eyear = year(enddate)) %>%
  gsfuns::generateSeries(., "syear", "eyear", varname = "year") %>%
  mutate(dec31st = ymd(paste(year, 12, 31, sep = "-"))) %>%
  filter(dec31st %within% dateiv, 
         dec31st %within% dateiv.1, 
         year <= 2018)

## Compute territorial fractionalization variables using yearly group-segment data
geoepr.ag.tfrac <- geoepr.cs.yrs %>% 
  dplyr::select(ag_id, year, seg.area) %>%
  group_by(ag_id, year) %>%
  summarize(tfrac = 1 - sum((seg.area / sum(seg.area))^2)) %>%
  group_by(ag_id) %>%
  arrange(ag_id, year) %>%
  mutate(split = ifelse(tfrac > 0, 1, 0),
         tfrac_incr = ifelse(tfrac >= cummin(tfrac), tfrac - cummin(tfrac), 0)) %>%
  mutate_at(vars(contains("tfrac")), function(x){round(x,5)})

## Compute territorial fractionalization increases after 1945
geoepr.ag.tfrac.post46 <- geoepr.ag.tfrac %>%
  filter(year > 1945) %>%
  mutate(tfrac_incr_post1946 = ifelse(tfrac >= cummin(tfrac), tfrac - cummin(tfrac), 0)) %>%
  dplyr::select(ag_id, year, tfrac_incr_post1946)

## Compute territorial fractionalization increases up to 1945
geoepr.ag.tfrac.pre46 <- geoepr.ag.tfrac %>%
  filter(year == 1945) %>%
  mutate(tfrac_incr_pre1946 = tfrac_incr) %>%
  dplyr::select(ag_id, tfrac_incr_pre1946)

## Compute territorial fractionalization after 1918
geoepr.ag.tfrac.post18 <- geoepr.ag.tfrac %>%
  filter(year > 1918) %>%
  mutate(tfrac_incr_post1918 = ifelse(tfrac >= cummin(tfrac), tfrac - cummin(tfrac), 0)) %>%
  dplyr::select(ag_id, year, tfrac_incr_post1918)

## Compute population-based fractionalization variables (used in robustness analyses)
geoepr.ag.pfrac <- geoepr.cs.yrs %>% 
  dplyr::select(ag_id, year, pop) %>%
  group_by(ag_id, year) %>%
  summarize(pfrac = 1 - sum((pop / sum(pop))^2)) %>%
  group_by(ag_id) %>%
  arrange(ag_id, year) %>%
  mutate(pfrac_incr = ifelse(pfrac >= cummin(pfrac), pfrac - cummin(pfrac), 0)) %>%
  mutate_at(vars(contains("pfrac")), function(x){round(x,5)})

## Compute population fractionalization increases  after 1945
geoepr.ag.pfrac.post46 <- geoepr.ag.pfrac %>%
  filter(year > 1945) %>%
  mutate(pfrac_incr_post1946 = ifelse(pfrac >= cummin(pfrac), pfrac - cummin(pfrac), 0)) %>%
  dplyr::select(ag_id, year, pfrac_incr_post1946)

## Add AG-level control for total size of settlement area in each year
geoepr.ag.ctrls <- geoepr.ag %>% 
  cbind(., st_coordinates(st_centroid(geoepr.ag))) %>%
  mutate(syear = year(sdate), 
         eyear = year(edate),
         ag_area_sqkm = as.numeric(st_area(geometry))*1e-6) %>%
  generateSeries(., "syear", "eyear", varname = "year") %>%
  mutate(dec31st = ymd(paste(year, 12, 31, sep = "-"))) %>%
  filter(dec31st %within% dateiv) %>%
  dplyr::select(ag_id, year, ag_area_sqkm, X, Y) %>%
  mutate(ln_ag_area_sqkm = log(1 + ag_area_sqkm))

## Code SDM claim variables
epr.claims.out <- epr.claims %>%
  distinct() %>%
  left_join(egip.claims, by = c("gwgroupid", "year")) %>%
  group_by(gwgroupid, year) %>%
  ## Code a dummy variable for secessionist or irredentist claims (values 2,3)
  mutate(claim2 = ifelse(!is.na(claim),
                         ifelse(claim > 1 & !is.na(claim), 1, 0), NA),
         ## include corresponding claims made by kin-state government (egip_claim)
         allclaim2 = pmax(claim2, egip_claim, na.rm = T),
         ## Code a dummy variable for irredentist claims only (value 3)
         claim3 = ifelse(!is.na(claim),
                         ifelse(claim > 2 & !is.na(claim), 1, 0), NA),
         ## include corresponding claims made by kin-state government (egip_claim)
         allclaim3 = pmax(claim3, egip_claim, na.rm = T)) %>%
  dplyr::select(gwgroupid, year, claim, claim2, allclaim2, claim3, allclaim3) 

## Code aggregate group-level for political status:
## 1: all segments within the AG are excluded
## 2: at least one segment has government power
epr.ag.df$ag_all_excl <- ifelse(epr.ag.df$ag_excl_share == 1, 1, 0)
epr.ag.df$ag_incl <- ifelse(epr.ag.df$ag_egip_share > 0, 1, 0)

epr.ag.status.dum <- epr.ag.df %>%
  mutate(ag_all_excl = ifelse(epr.ag.df$ag_excl_share == 1, 1, 0),
         ag_incl = ifelse(epr.ag.df$ag_egip_share > 0, 1, 0)) %>%
  dplyr::select(ag_id, year, ag_all_excl, ag_incl) %>%
  arrange(ag_id, year)

## Combine results into analysis dataset
epr.seg.df.out <- epr.seg.df %>% 
  left_join(geoepr.ag.tfrac, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.tfrac.post46, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.tfrac.pre46, by = c("ag_id")) %>%
  left_join(geoepr.ag.pfrac, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.pfrac.post46, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.ctrls, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.tfrac.post18, by = c("ag_id", "year")) %>%
  left_join(epr.ag.status.dum, by = c("ag_id", "year")) %>%
  left_join(epr.claims.out, by = c("gwgroupid", "year")) %>%
  group_by(gwgroupid, year) %>%
  mutate(ln_state_age = log(state_age + 1)) %>%
  dplyr::select(countries_gwid, ag_id, year, gwgroupid, groupname, 
                         onset_do_flag, split, tfrac, tfrac_incr, tfrac_incr_post1946,
                         tfrac_incr_pre1946, tfrac_incr_post1918, pfrac, 
                         pfrac_incr_post1946, pfrac_incr, ln_ag_area_sqkm, 
                         ag_incidence_flag_lag, ag_all_excl, ag_incl, status_excl, 
                         downgraded2, rbal, warhist, ln_capdist, ln_rgdppc_lag, 
                         ln_pop_lag, colonial_past, ln_state_age, peaceyears, 
                         isrelevant, status_monopoly, status_dominant, 
                         seg_area_sqkm, X, Y, allclaim2, allclaim3)

## Save analysis dataset
write.dta(epr.seg.df.out, "epr_segment_level_analysis.dta")

################################################################################
## Output AG-level dataset (used in robustness)
################################################################################

## Join ag-level dataset with tfrac variables calculated above
epr.ag.df.out <- epr.ag.df %>% 
  left_join(geoepr.ag.tfrac, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.tfrac.post46, by = c("ag_id", "year")) %>%
  left_join(geoepr.ag.tfrac.pre46, by = c("ag_id")) %>%
  dplyr::select(ag_id, year, ag_onset_ko_flag, split, tfrac, 
                tfrac_incr_post1946, tfrac_incr_pre1946, ag_excl_share,
                ln_ag_area_sqkm, ag_warhist, ag_incidence_flag_lag, ag_peaceyears)

## Save analysis dataset
write_dta(epr.ag.df.out, "epr_ag_level_analysis.dta")

################################################################################
################################################################################
################################################################################
## Prepare analysis dataset 2: Historical map of Europe
################################################################################
################################################################################
################################################################################

################################################################################
## Load data
################################################################################

## Load ethnographic map of Europe in 1918 and map extent boundary (hand-coded)
eur1918.map <- st_read("eur_map_1918_polygons.geojson")
eur1918.bnd <- st_read("eur_map_1918_boundary.geojson")

## Load CSV file that matches geoepr with groups on historical maps (hand-coded)
geoepr2eurmap <- read.csv("geoepr2eur_map.csv", stringsAsFactors = F)

################################################################################
## Process data
################################################################################

## Merge groups on historical map with AG ids via matching table
ag2gwgroupid <- epr.seg.df %>% 
  distinct(gwgroupid, ag_id, groupname)

ag2eurmap <- geoepr2eurmap %>%
  distinct(gwgroupid, geoepr_group, eur_map_group) %>%
  left_join(ag2gwgroupid, by = "gwgroupid") %>%
  mutate(ag_id = ifelse(is.na(ag_id), gwgroupid, ag_id)) %>%
  distinct(ag_id, eur_map_group) %>%
  filter(eur_map_group != "")

## Tag groups that are cut off by map boundary (box) and remove them 
## (except Russians and Zyrians: Only minor parts of group are cut off)
eur1918.map.prep <- eur1918.map %>% 
  st_join(eur1918.bnd) %>% 
  mutate(border_grp = ifelse(!is.na(FID), 1, 0)) %>%
  mutate(border_grp = ifelse(grepl("Russ|Zyri", Groups), 0, border_grp)) %>%
  group_by(Groups, border_grp) %>%
  dplyr::summarize(geometry = st_union(geometry)) %>%
  left_join(ag2eurmap, by = c("Groups" = "eur_map_group")) %>%
  filter(border_grp == 0) %>% 
  group_by(ag_id) %>%
  dplyr::summarize(
    group = paste(Groups, collapse = ", "),
    geometry = st_union(geometry)) 

## Calculate area size of each group
eur1918.map.areas <- eur1918.map.prep %>%
  mutate(ag_area_sqkm = as.numeric(st_area(geometry))*1e-6) %>%
  mutate(ln_ag_area_sqkm = log(ag_area_sqkm + 1)) %>%
  st_drop_geometry() %>%
  dplyr::select(ag_id, contains("area"))

## Intersect group polygons with country borders
eur1918.cs <- eur1918.map.prep %>%
  st_intersection(., cs) 

## Get territorial fractionalization variables
eur1918.cs.tfrac <- eur1918.cs %>%
  mutate(syear = year(startdate),
         eyear = year(enddate)) %>%
  mutate(seg_area = as.numeric(st_area(geometry) * 1e-3)) %>%
  st_drop_geometry() %>%
  ## Expand into yearly data (January 1st of each year)
  generateSeries(., "syear", "eyear", varname = "year") %>%
  mutate(jan1st = ymd(paste(year, 01, 01, sep = "-"))) %>%
  filter(jan1st >= startdate, jan1st <= enddate) %>%
  ## Compute area sizes and territorial fractionalization
  group_by(ag_id, group, gwcode, year) %>%
  dplyr::summarize(seg_area = sum(seg_area)) %>%
  group_by(ag_id, group, year) %>%
  mutate(seg_share = seg_area / sum(seg_area)) %>%
  dplyr::summarize(tfrac_1918 = 1 - sum(seg_share^2)) %>%
  dplyr::select(ag_id, group, year, tfrac_1918) %>%
  ## Compute increases in territorial fractionalization over time
  group_by(ag_id) %>%
  arrange(ag_id, year) %>%
  mutate_at(vars(contains("frac")), list(incr = getTFIncr)) 

## Match with original tfrac data
eur1918.cs.tfrac.out.df <- geoepr.ag.tfrac %>%
  inner_join(eur1918.cs.tfrac, by = c("ag_id", "year")) %>% 
  dplyr::select(ag_id, year, group, tfrac, tfrac_1918) %>%
  mutate(tfrac_hist = ifelse(year < 1945, tfrac_1918, tfrac)) %>%
  group_by(ag_id) %>%
  arrange(ag_id, year) %>%
  mutate_at(vars(contains("frac")), list(incr = getTFIncr)) %>%
  left_join(eur1918.map.areas, by = "ag_id")

## Get group area size
epr.seg.hist.out <- epr.seg.df %>%
  dplyr::select(-contains("frac"), -contains("area")) %>%
  left_join(eur1918.cs.tfrac.out.df, by = c("ag_id", "year")) %>%
  dplyr::select(countries_gwid, ag_id, year, gwgroupid, groupname, ag_id, year, 
                onset_do_flag, tfrac, tfrac_incr, tfrac_hist_incr, 
                ln_ag_area_sqkm, ag_incidence_flag_lag, status_excl, 
                status_monopoly, status_dominant, downgraded2, rbal,
                warhist, ln_rgdppc_lag, ln_pop_lag, ln_capdist, colonial_past,
                ln_state_age, peaceyears, isrelevant, ln_ag_area_sqkm)

## Save analysis dataset
write.dta(epr.seg.hist.out, file.path("eur_map_1918_analysis.dta"))

################################################################################
################################################################################
################################################################################
## Prepare analysis dataset 3: Murdock's tribal map of Africa
################################################################################
################################################################################
################################################################################

################################################################################
## Load data
################################################################################

## Load Murdock polygons
md <- st_read("borders_tribes.geojson") %>%
  rename_all(tolower) %>%
  filter(tribe_code>0)

## Load GED conflict data
ged <- read.csv("ged191.csv", stringsAsFactors=F)
ged.sf <- st_as_sf(ged,
                   coords = c("longitude", "latitude"),
                   crs = 4326)

################################################################################
## Data processing
################################################################################

## Code conflict onset: Get first event for each GED/UCDP conflict id 
## (Only statebased conflicts that started after Jan 1st, 1989)
ged.os <- ged.sf %>%
  group_by(conflict_new_id) %>%
  arrange(conflict_new_id, date_start) %>%
  slice(1) %>%
  ungroup() %>%
  filter(date_start>'1989-01-01',
         type_of_violence == 1)

## Intersect murdock polygons with country borders and compute settlement area 
## sizes in each period
md.cs <- md %>%
  mutate(ag.area.sqkm = as.numeric(st_area(.))*1e-6) %>%
  st_intersection(cs) %>%
  mutate(seg.area.sqkm = as.numeric(st_area(.))*1e-6) %>%
  filter(seg.area.sqkm/ag.area.sqkm >= 0.1) %>%
  mutate(share = seg.area.sqkm/ag.area.sqkm) %>%
  mutate(syear = year(startdate),
         eyear = year(enddate)) %>%
  st_drop_geometry()

## Calculate yearly territorial fractionalization variables
md.tfrac.yrs <- md.cs %>% 
  generateSeries(., "syear", "eyear", varname = "year") %>%
  mutate(jan1st = ymd(paste(year, 01, 01, sep="-"))) %>%
  filter(jan1st >= startdate,
         jan1st <= enddate) %>%
  dplyr::select(tribe_code, gwcode, year, share) %>%
  group_by(tribe_code, year) %>%
  summarize(tfrac = 1 - sum(share^2)) %>%
  group_by(tribe_code) %>%
  mutate(tfrac.min = cummin(tfrac),
         split = ifelse(tfrac > 0, 1, 0)) %>%
  mutate(tfrac.incr = ifelse(tfrac >= tfrac.min, tfrac-tfrac.min, 0)) %>%
  dplyr::select(-tfrac.min)

## Code statebased conflict onset by murdock polygon
md.ged <- st_join(md, ged.os) %>%
  st_drop_geometry() %>%
  group_by(tribe_code) %>%
  summarize(statebased.ct = n_distinct(id, na.rm=T)) %>%
  mutate(statebased.os = ifelse(statebased.ct > 0, 1, 0))

## Controls: Population in 1880, terrain ruggedness
getLog <- function(x){log(1+x)}

md.ctrls <- data.frame(tribe_code = md$tribe_code,
                       pop1880 = velox(pop1880.r)$extract(md, fun=function(x){
                         sum(x, na.rm=T)}, small=TRUE),
                       elev.sd = velox(gtopo.r)$extract(md, fun=function(x){
                         sd(x, na.rm=T)}, small=TRUE),
                       area.sqkm = as.numeric(st_area(md))*1e-6) %>%
  mutate_at(vars(matches("pop|area")), list(log=getLog))


## Add controls: capital distance (km), french colony, british colony

## For capital distance, compute largest intersection between group and country 
## in given year 
## (e.g. Group X is mainly located in country Y --> Distance to Y's capital)
md2gw <- generateSeries(md.cs, "syear", "eyear", varname = "year") %>%
  mutate(jan1st = ymd(paste(year, 01, 01, sep="-"))) %>%
  filter(jan1st >= startdate,
         jan1st <= enddate,
         year == 1989) %>%
  arrange(tribe_code, desc(share)) %>%
  group_by(tribe_code) %>%
  slice(1) %>%
  dplyr::select(tribe_code, gwcode, caplong, caplat) %>%
  ungroup()

## Get country capitals 
cs.caps <- st_as_sf(md2gw,
                    coords = c("caplong", "caplat"),
                    crs = 4326)

## Calculate capital distance for each group
md.capdist <- do.call(rbind, mclapply(1:nrow(md), function(x){
  md.row <- md[x,]
  cap <- cs.caps %>% 
    filter(tribe_code == md.row$tribe_code)
  md.row$capdist <- as.numeric(st_distance(st_centroid(md.row), cap))*1e-3
  md.row$ln.capdist <- log(md.row$capdist+1)
  return(md.row)
}, mc.cores = NCORES))

## Save results without polygon
md.capdist.vars <- md.capdist %>%
  st_drop_geometry() %>%
  dplyr::select(contains("code"), contains("dist"))

## Code a dummy variable for french vs british colony, using Cshapes
col.hist <- cs %>%
  st_drop_geometry() %>%
  filter(!status==1) %>%
  group_by(gwcode) %>%
  arrange(gwcode, startdate) %>%
  slice(n()) %>%
  mutate(french = ifelse(sovereignty == 220, 1, 0),
         british = ifelse(sovereignty == 200, 1, 0)) %>%
  dplyr::select(gwcode, french, british)

## Combine country controls
md.ctry.ctrls <- md2gw %>%
  left_join(md.capdist.vars, by = "tribe_code") %>%
  left_join(col.hist, by = "gwcode") %>%
  replace_na(list(french = 0, british = 0))

## Create analysis dataframe
md.df <- md %>%
  left_join(filter(md.tfrac.yrs, year==1989), by = "tribe_code") %>%
  left_join(md.ged, by = "tribe_code") %>%
  left_join(md.ctrls, by = "tribe_code") %>%
  left_join(md.ctry.ctrls, by = "tribe_code") %>%
  rename_all(~gsub(".","_",., fixed = T)) %>%
  dplyr::select(name, tribe_code, year, statebased_os, split, tfrac, tfrac_incr, 
                pop1880_log, area_sqkm_log, elev_sd, ln_capdist, french,
                british, gwcode)

## Save analysis dataset
write.dta(st_drop_geometry(md.df), "murdock_analysis.dta")

################################################################################
################################################################################
################################################################################
## Create descriptive figures shown in main text
################################################################################
################################################################################
################################################################################

################################################################################
## Figure 1: Map of Kurds in Middle East
################################################################################

## Get polygons: Kurds and borders in 2017
kurd.poly <- geoepr.ag %>% filter(grepl("Kurd", groupname))
cs2017 <- cs %>% filter(startdate <= "2017-01-01", enddate >= "2017-01-01")
cs.lm <- cs2017 %>% st_union()

## Define map extent
xl <- c(26, 47)
yl <- c(33, 42)

kurds.plot <- ggplot() +
  geom_sf(data = cs.lm) + 
  geom_sf(data = kurd.poly, fill = "#ED7953FF",  size = 0.3) +
  geom_sf(data = cs2017, size = 0.6, fill = NA, col = "black") + 
  coord_sf(datum = NA, xlim = xl, ylim = yl) + 
  theme_bw()

pdf("dataverse_files/kurds_plot.pdf", 7, 4)
kurds.plot
dev.off()

################################################################################
## Figure 4: Cshapes snapshots of South-East Europe
################################################################################

## Subset data
dates <- c("1886-01-01", "1913-08-10", "1920-06-05", "1946-01-01")
cs.subsets <- do.call(rbind, lapply(dates, function(x){
  cs %>%
    filter(startdate <= x, enddate >= x) %>%
    mutate(date = x)
}))

## Define map extent
xl <- c(10.5, 34)
yl <- c(36.5, 52)

cs.preview.plots <- ggplot() +
  geom_sf(data = cs.subsets, size = 0.4, col = "black") + 
  coord_sf(datum = NA, xlim = xl, ylim = yl) + 
  facet_wrap(vars(date)) + 
  theme_bw()

pdf("dataverse_files/cs_snapshots.pdf", 6, 6)
cs.preview.plots
dev.off()

################################################################################
## Figure 9: Murdock's tribal map of Africa
################################################################################

## Get African borders and landmass polygons
cs.afr <- cs %>% 
  filter(enddate >= "2017-12-31", 
         gwcode %in% c(400:626, 651)) 

cs.afr.lm <- st_union(cs.afr)

md.plot <- ggplot() + 
  geom_sf(data = cs.afr.lm, fill = "black") +
  geom_sf(data = md.df, aes(fill = tfrac), size = 0.3) + 
  geom_sf(data = cs.afr, fill = NA, size = 0.7, col = "black") + 
  scale_fill_gradient2(low = "grey90", high = "grey20", name = "Fractionalization") + 
  theme_bw() + 
  coord_sf(datum = NA, xlim = c(-17, 50), ylim = c(-33, 36))

pdf("dataverse_files/murdock_plot.pdf", 7, 6)
md.plot
dev.off()

################################################################################
## Figure A4: Historical map of Europe 1918
################################################################################
xl <- c(-23, 65)
yl <- c(35, 71)

eur1918.plot <- ggplot() + 
  geom_sf(data = cs.lm) +
  geom_sf(data = eur1918.map.prep, fill = "white", size = 0.4) + 
  geom_sf(data = eur1918.map.prep, aes(fill = group), alpha = 0.4, size = 0.4) + 
  coord_sf(datum = st_crs(3048), xlim = xl, ylim = yl) + 
  theme_bw() + 
  theme(legend.position = "none", 
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())
  
pdf("dataverse_files/eur1918_plot.pdf", 7, 6)
eur1918.plot
dev.off()
